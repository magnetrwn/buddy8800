<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>buddy8800: cpu&lt; bus_iface &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">buddy8800
   </div>
   <div id="projectbrief">An Altair 8800 S-100 emulator that can run CP/M through a serial PTY.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcpu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcpu-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpu&lt; bus_iface &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the CPU of the emulator.  
 <a href="classcpu.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cpu_8hpp_source.html">cpu.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3370e515b29f14c07755eb9990d9aa31"><td class="memItemLeft" align="right" valign="top"><a id="a3370e515b29f14c07755eb9990d9aa31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cpu</b> (bus_iface init_adr_space)</td></tr>
<tr class="separator:a3370e515b29f14c07755eb9990d9aa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CPU API methods.</div></td></tr>
<tr class="memitem:a7a01c8c57ae52af3126b88042cd1aa63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a7a01c8c57ae52af3126b88042cd1aa63">step</a> (usize steps=1)</td></tr>
<tr class="memdesc:a7a01c8c57ae52af3126b88042cd1aa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steps the CPU by one instruction (and its operands).  <a href="classcpu.html#a7a01c8c57ae52af3126b88042cd1aa63">More...</a><br /></td></tr>
<tr class="separator:a7a01c8c57ae52af3126b88042cd1aa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e1736be271fe78087dee008490199b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#ab3e1736be271fe78087dee008490199b">execute</a> (u8 opcode, u8 operand1, u8 operand2=0)</td></tr>
<tr class="memdesc:ab3e1736be271fe78087dee008490199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a single opcode with one or two operands.  <a href="classcpu.html#ab3e1736be271fe78087dee008490199b">More...</a><br /></td></tr>
<tr class="separator:ab3e1736be271fe78087dee008490199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70c847732b6891a759352d27e896ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a9d70c847732b6891a759352d27e896ee">execute</a> (u8 opcode)</td></tr>
<tr class="memdesc:a9d70c847732b6891a759352d27e896ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a single opcode.  <a href="classcpu.html#a9d70c847732b6891a759352d27e896ee">More...</a><br /></td></tr>
<tr class="separator:a9d70c847732b6891a759352d27e896ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d839c16cc808245a4f0c38a430a342a"><td class="memTemplParams" colspan="2">template&lt;typename T , T_ITERATOR_SFINAE &gt; </td></tr>
<tr class="memitem:a0d839c16cc808245a4f0c38a430a342a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpu.html#a0d839c16cc808245a4f0c38a430a342a">load</a> (T begin, T end, usize offset=0, bool auto_reset_vector=false)</td></tr>
<tr class="memdesc:a0d839c16cc808245a4f0c38a430a342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads data into cardbus.  <a href="classcpu.html#a0d839c16cc808245a4f0c38a430a342a">More...</a><br /></td></tr>
<tr class="separator:a0d839c16cc808245a4f0c38a430a342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c72852ac69a7814d8e0faa836d3abf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a6c72852ac69a7814d8e0faa836d3abf3">load_state</a> (const <a class="el" href="structcpu__state.html">cpu_state</a> &amp;new_state)</td></tr>
<tr class="memdesc:a6c72852ac69a7814d8e0faa836d3abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load CPU state.  <a href="classcpu.html#a6c72852ac69a7814d8e0faa836d3abf3">More...</a><br /></td></tr>
<tr class="separator:a6c72852ac69a7814d8e0faa836d3abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6100df727ce03c23512fee8d2698fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcpu__state.html">cpu_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#ae6100df727ce03c23512fee8d2698fc5">save_state</a> () const</td></tr>
<tr class="memdesc:ae6100df727ce03c23512fee8d2698fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save CPU state.  <a href="classcpu.html#ae6100df727ce03c23512fee8d2698fc5">More...</a><br /></td></tr>
<tr class="separator:ae6100df727ce03c23512fee8d2698fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010e335fc9f1797e72bfc5585e9238f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a010e335fc9f1797e72bfc5585e9238f6">is_halted</a> () const</td></tr>
<tr class="memdesc:a010e335fc9f1797e72bfc5585e9238f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the CPU is halted.  <a href="classcpu.html#a010e335fc9f1797e72bfc5585e9238f6">More...</a><br /></td></tr>
<tr class="separator:a010e335fc9f1797e72bfc5585e9238f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431272df1fa9db7b37770dd95702807"><td class="memItemLeft" align="right" valign="top"><a id="a2431272df1fa9db7b37770dd95702807"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a2431272df1fa9db7b37770dd95702807">clear</a> ()</td></tr>
<tr class="memdesc:a2431272df1fa9db7b37770dd95702807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the CPU. <br /></td></tr>
<tr class="separator:a2431272df1fa9db7b37770dd95702807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Test related methods.</div></td></tr>
<tr class="memitem:ad684d25913e8aaf0139fa3dc47ce9e40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#ad684d25913e8aaf0139fa3dc47ce9e40">do_pseudo_bdos</a> (bool should)</td></tr>
<tr class="memdesc:ad684d25913e8aaf0139fa3dc47ce9e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU to resolve calls to BDOS internally.  <a href="classcpu.html#ad684d25913e8aaf0139fa3dc47ce9e40">More...</a><br /></td></tr>
<tr class="separator:ad684d25913e8aaf0139fa3dc47ce9e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf017b99cf39776da5a4bf517fb9226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#abbf017b99cf39776da5a4bf517fb9226">set_pseudo_bdos_redirect</a> (const char *filename)</td></tr>
<tr class="memdesc:abbf017b99cf39776da5a4bf517fb9226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect pseudo BDOS print routines to a file.  <a href="classcpu.html#abbf017b99cf39776da5a4bf517fb9226">More...</a><br /></td></tr>
<tr class="separator:abbf017b99cf39776da5a4bf517fb9226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850125d4d67383c10cbb1ba594d1db18"><td class="memItemLeft" align="right" valign="top"><a id="a850125d4d67383c10cbb1ba594d1db18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a850125d4d67383c10cbb1ba594d1db18">reset_pseudo_bdos_redirect</a> ()</td></tr>
<tr class="memdesc:a850125d4d67383c10cbb1ba594d1db18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect pseudo BDOS print routines back to stdout. <br /></td></tr>
<tr class="separator:a850125d4d67383c10cbb1ba594d1db18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interrupt related methods.</div></td></tr>
<tr class="memitem:a4228c63bc0f368cf39bfe37909f73f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a4228c63bc0f368cf39bfe37909f73f45">interrupt</a> (std::array&lt; u8, 3 &gt; inst)</td></tr>
<tr class="memdesc:a4228c63bc0f368cf39bfe37909f73f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an interrupt and push PC, then disable interrupts.  <a href="classcpu.html#a4228c63bc0f368cf39bfe37909f73f45">More...</a><br /></td></tr>
<tr class="separator:a4228c63bc0f368cf39bfe37909f73f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class bus_iface = bus&amp;&gt;<br />
class cpu&lt; bus_iface &gt;</h3>

<p>Represents the CPU of the emulator. </p>
<p>This is the 8080 CPU emulator and interpreter. It abstracts the CPU functionality into straightforward methods and presents a way to step and interact with state. Being an interpreter, each opcode starting from the program counter address in cardbus is fetched and executed according to what it represents and including further fetches to opcode operands. The API also provides public access to <a class="el" href="classcpu.html#ab3e1736be271fe78087dee008490199b" title="Executes a single opcode with one or two operands.">execute()</a>, should the user want to manually ask for instructions.</p>
<dl class="section note"><dt>Note</dt><dd>The class is completely defined in this header to allow templating the class to determine what bus interface <code>bus_iface</code> to use. For example, you can:<ul>
<li><code>cpu&lt;bus&amp;&gt; <a class="el" href="classcpu.html" title="Represents the CPU of the emulator.">cpu(cardbus)</a>;</code> or <code>cpu&lt;&gt; <a class="el" href="classcpu.html" title="Represents the CPU of the emulator.">cpu(cardbus)</a>;</code> to create a standard CPU that interacts with a bus, or</li>
<li><code>cpu&lt;std::array&lt;u8, 65536&gt;&gt; cpu;</code> to instead have an empty array as a bus, for max performance! </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad684d25913e8aaf0139fa3dc47ce9e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad684d25913e8aaf0139fa3dc47ce9e40">&#9670;&nbsp;</a></span>do_pseudo_bdos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::do_pseudo_bdos </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CPU to resolve calls to BDOS internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">should</td><td>Whether the CPU should handle BDOS calls.</td></tr>
  </table>
  </dd>
</dl>
<p>This method enables pseudo BDOS functionality by the CPU itself. This can be essential for testing the CPU, as most diagnostic programs expect the system to be able to print messages. </p>

</div>
</div>
<a id="a9d70c847732b6891a759352d27e896ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d70c847732b6891a759352d27e896ee">&#9670;&nbsp;</a></span>execute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::execute </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a single opcode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>The opcode to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is a comprehensive jump table for all the opcodes the 8080 CPU can execute. It effectively groups the decode and execute phases of the CPU into a single method, and is used by the step method to execute instructions.</p>
<dl class="section note"><dt>Note</dt><dd>To allow multiple operand instructions, there is an overload of this method that takes one or two extra argument bytes and temporarily redirects <code>fetch()</code> and <code>fetch2()</code> to them during the instruction cycle! </dd></dl>

</div>
</div>
<a id="ab3e1736be271fe78087dee008490199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e1736be271fe78087dee008490199b">&#9670;&nbsp;</a></span>execute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::execute </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>operand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>operand2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a single opcode with one or two operands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>The opcode to execute. </td></tr>
    <tr><td class="paramname">operand1</td><td>The first operand to the opcode. </td></tr>
    <tr><td class="paramname">operand2</td><td>The second operand to the opcode.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overload that manipulates the way the fetch cycles interact in the CPU logic: it will use the operands retrieved by this method (usually to be placed by a device on the bus that called an IRQ) instead of fetching them from the bus cards. In fact, this is used by the interrupt method as well. </p>

<p class="reference">Referenced by <a class="el" href="classcpu.html#a4228c63bc0f368cf39bfe37909f73f45">cpu&lt; bus_iface &gt;::interrupt()</a>, and <a class="el" href="classcpu.html#a7a01c8c57ae52af3126b88042cd1aa63">cpu&lt; bus_iface &gt;::step()</a>.</p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcpu_ab3e1736be271fe78087dee008490199b_icgraph.png" border="0" usemap="#aclasscpu_ab3e1736be271fe78087dee008490199b_icgraph" alt=""/></div>
<map name="aclasscpu_ab3e1736be271fe78087dee008490199b_icgraph" id="aclasscpu_ab3e1736be271fe78087dee008490199b_icgraph">
<area shape="rect" title="Executes a single opcode with one or two operands." alt="" coords="163,31,267,57"/>
<area shape="rect" href="classcpu.html#a4228c63bc0f368cf39bfe37909f73f45" title="Call an interrupt and push PC, then disable interrupts." alt="" coords="5,5,115,32"/>
<area shape="rect" href="classcpu.html#a7a01c8c57ae52af3126b88042cd1aa63" title="Steps the CPU by one instruction (and its operands)." alt="" coords="19,56,101,83"/>
</map>
</div>

</div>
</div>
<a id="a4228c63bc0f368cf39bfe37909f73f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4228c63bc0f368cf39bfe37909f73f45">&#9670;&nbsp;</a></span>interrupt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::interrupt </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; u8, 3 &gt;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call an interrupt and push PC, then disable interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>The interrupt instruction (with optional operands) to execute out of place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>This allows any instruction and any retrieval of arguments, but I'm not sure if that happens other than on <code>CALL</code>. </dd></dl>

<p class="reference">References <a class="el" href="classcpu.html#ab3e1736be271fe78087dee008490199b">cpu&lt; bus_iface &gt;::execute()</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcpu_a4228c63bc0f368cf39bfe37909f73f45_cgraph.png" border="0" usemap="#aclasscpu_a4228c63bc0f368cf39bfe37909f73f45_cgraph" alt=""/></div>
<map name="aclasscpu_a4228c63bc0f368cf39bfe37909f73f45_cgraph" id="aclasscpu_a4228c63bc0f368cf39bfe37909f73f45_cgraph">
<area shape="rect" title="Call an interrupt and push PC, then disable interrupts." alt="" coords="5,5,115,32"/>
<area shape="rect" href="classcpu.html#ab3e1736be271fe78087dee008490199b" title="Executes a single opcode with one or two operands." alt="" coords="163,5,267,32"/>
</map>
</div>

</div>
</div>
<a id="a010e335fc9f1797e72bfc5585e9238f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010e335fc9f1797e72bfc5585e9238f6">&#9670;&nbsp;</a></span>is_halted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::is_halted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the CPU is halted. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the CPU is halted, false otherwise. </dd></dl>

</div>
</div>
<a id="a0d839c16cc808245a4f0c38a430a342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d839c16cc808245a4f0c38a430a342a">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<div class="memtemplate">
template&lt;typename T , T_ITERATOR_SFINAE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::load </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_reset_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads data into cardbus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the beginning of data. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to the end of data. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset to try to start loading at. </td></tr>
    <tr><td class="paramname">auto_reset_vector</td><td>Whether the zero page should point to the start of loaded data automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;std::out_of_range&lt;/tt&gt;</td><td>if data won't fit in cardbus. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;std::out_of_range&lt;/tt&gt;</td><td>if enabled auto reset vector will overwrite the first few bytes loaded.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be useful to load programs, libraries, or data into the emulator's cardbus. It will copy the data at the specified offset, check if it will fit, and if auto_reset_vector is true, it will set the zero page (the first 3 bytes of cardbus, specifically a jump instruction and a 2 byte argument) to point to the start of the loaded data.</p>
<dl class="section note"><dt>Note</dt><dd>This method calls <code>write_force()</code> on the cards when using a bus, so it can also write to locked ROM to setup the system roms. </dd></dl>

</div>
</div>
<a id="a6c72852ac69a7814d8e0faa836d3abf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c72852ac69a7814d8e0faa836d3abf3">&#9670;&nbsp;</a></span>load_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::load_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpu__state.html">cpu_state</a> &amp;&#160;</td>
          <td class="paramname"><em>new_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load CPU state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_state</td><td>The state to load.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can set a new state to the CPU, including all registers and flags of it. </p>

</div>
</div>
<a id="ae6100df727ce03c23512fee8d2698fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6100df727ce03c23512fee8d2698fc5">&#9670;&nbsp;</a></span>save_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcpu__state.html">cpu_state</a> <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::save_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save CPU state. </p>
<dl class="section return"><dt>Returns</dt><dd>The current state of the CPU.</dd></dl>
<p>This method will return the current state of the CPU, including all registers and flags of it. </p>

</div>
</div>
<a id="abbf017b99cf39776da5a4bf517fb9226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf017b99cf39776da5a4bf517fb9226">&#9670;&nbsp;</a></span>set_pseudo_bdos_redirect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::set_pseudo_bdos_redirect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect pseudo BDOS print routines to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to print to. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="classutil_1_1print__helper.html#a08912c4069c431b6080355b8a7c18c15">util::print_helper::set()</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcpu_abbf017b99cf39776da5a4bf517fb9226_cgraph.png" border="0" usemap="#aclasscpu_abbf017b99cf39776da5a4bf517fb9226_cgraph" alt=""/></div>
<map name="aclasscpu_abbf017b99cf39776da5a4bf517fb9226_cgraph" id="aclasscpu_abbf017b99cf39776da5a4bf517fb9226_cgraph">
<area shape="rect" title="Redirect pseudo BDOS print routines to a file." alt="" coords="5,5,171,47"/>
<area shape="rect" href="classutil_1_1print__helper.html#a08912c4069c431b6080355b8a7c18c15" title="Set a redirection to file." alt="" coords="219,13,376,39"/>
</map>
</div>

</div>
</div>
<a id="a7a01c8c57ae52af3126b88042cd1aa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a01c8c57ae52af3126b88042cd1aa63">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::step </td>
          <td>(</td>
          <td class="paramtype">usize&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steps the CPU by one instruction (and its operands). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">steps</td><td>The number of steps to forward the CPU by.</td></tr>
  </table>
  </dd>
</dl>
<p>Calling the step method will fetch the next instruction opcode from cardbus and execute it. Internally, on every fetch the PC is incremented, and each instruction is also responsible for fetching its operands, so a step is effectively a full instruction step.</p>
<p>If the CPU is set to handle BDOS calls, it will provide some pseudo BDOS functionality, currently only for printing characters and strings to wherever the printer is set to, stdout by default.</p>
<dl class="section note"><dt>Note</dt><dd>If the CPU is halted, this method will return immediately. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally, this method is calling <code>execute(fetch())</code>. </dd></dl>

<p class="reference">References <a class="el" href="classcpu.html#ab3e1736be271fe78087dee008490199b">cpu&lt; bus_iface &gt;::execute()</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classcpu_a7a01c8c57ae52af3126b88042cd1aa63_cgraph.png" border="0" usemap="#aclasscpu_a7a01c8c57ae52af3126b88042cd1aa63_cgraph" alt=""/></div>
<map name="aclasscpu_a7a01c8c57ae52af3126b88042cd1aa63_cgraph" id="aclasscpu_a7a01c8c57ae52af3126b88042cd1aa63_cgraph">
<area shape="rect" title="Steps the CPU by one instruction (and its operands)." alt="" coords="5,5,87,32"/>
<area shape="rect" href="classcpu.html#ab3e1736be271fe78087dee008490199b" title="Executes a single opcode with one or two operands." alt="" coords="135,5,239,32"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/core/cpu/<a class="el" href="cpu_8hpp_source.html">cpu.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classcpu.html">cpu</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
