<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>buddy8800: cpu&lt; bus_iface &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">buddy8800
   </div>
   <div id="projectbrief">An Altair 8800 S-100 emulator that can run CP/M through a serial PTY.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcpu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcpu-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cpu&lt; bus_iface &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents the CPU of the emulator.  
 <a href="classcpu.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cpu_8hpp_source.html">cpu.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3370e515b29f14c07755eb9990d9aa31"><td class="memItemLeft" align="right" valign="top"><a id="a3370e515b29f14c07755eb9990d9aa31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cpu</b> (bus_iface init_adr_space)</td></tr>
<tr class="separator:a3370e515b29f14c07755eb9990d9aa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">CPU API methods.</div></td></tr>
<tr class="memitem:acd0b563c6831d88a883f3bcd7d2257b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#acd0b563c6831d88a883f3bcd7d2257b4">step</a> ()</td></tr>
<tr class="memdesc:acd0b563c6831d88a883f3bcd7d2257b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steps the CPU by one instruction (and its operands).  <a href="classcpu.html#acd0b563c6831d88a883f3bcd7d2257b4">More...</a><br /></td></tr>
<tr class="separator:acd0b563c6831d88a883f3bcd7d2257b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70c847732b6891a759352d27e896ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a9d70c847732b6891a759352d27e896ee">execute</a> (u8 opcode)</td></tr>
<tr class="memdesc:a9d70c847732b6891a759352d27e896ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a single opcode.  <a href="classcpu.html#a9d70c847732b6891a759352d27e896ee">More...</a><br /></td></tr>
<tr class="separator:a9d70c847732b6891a759352d27e896ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d839c16cc808245a4f0c38a430a342a"><td class="memTemplParams" colspan="2">template&lt;typename T , T_ITERATOR_SFINAE &gt; </td></tr>
<tr class="memitem:a0d839c16cc808245a4f0c38a430a342a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpu.html#a0d839c16cc808245a4f0c38a430a342a">load</a> (T begin, T end, usize offset=0, bool auto_reset_vector=false)</td></tr>
<tr class="memdesc:a0d839c16cc808245a4f0c38a430a342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads data into cardbus.  <a href="classcpu.html#a0d839c16cc808245a4f0c38a430a342a">More...</a><br /></td></tr>
<tr class="separator:a0d839c16cc808245a4f0c38a430a342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c72852ac69a7814d8e0faa836d3abf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a6c72852ac69a7814d8e0faa836d3abf3">load_state</a> (const <a class="el" href="structcpu__state.html">cpu_state</a> &amp;new_state)</td></tr>
<tr class="memdesc:a6c72852ac69a7814d8e0faa836d3abf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load CPU state.  <a href="classcpu.html#a6c72852ac69a7814d8e0faa836d3abf3">More...</a><br /></td></tr>
<tr class="separator:a6c72852ac69a7814d8e0faa836d3abf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6100df727ce03c23512fee8d2698fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcpu__state.html">cpu_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#ae6100df727ce03c23512fee8d2698fc5">save_state</a> () const</td></tr>
<tr class="memdesc:ae6100df727ce03c23512fee8d2698fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save CPU state.  <a href="classcpu.html#ae6100df727ce03c23512fee8d2698fc5">More...</a><br /></td></tr>
<tr class="separator:ae6100df727ce03c23512fee8d2698fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010e335fc9f1797e72bfc5585e9238f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a010e335fc9f1797e72bfc5585e9238f6">is_halted</a> () const</td></tr>
<tr class="memdesc:a010e335fc9f1797e72bfc5585e9238f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the CPU is halted.  <a href="classcpu.html#a010e335fc9f1797e72bfc5585e9238f6">More...</a><br /></td></tr>
<tr class="separator:a010e335fc9f1797e72bfc5585e9238f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431272df1fa9db7b37770dd95702807"><td class="memItemLeft" align="right" valign="top"><a id="a2431272df1fa9db7b37770dd95702807"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a2431272df1fa9db7b37770dd95702807">clear</a> ()</td></tr>
<tr class="memdesc:a2431272df1fa9db7b37770dd95702807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the CPU. <br /></td></tr>
<tr class="separator:a2431272df1fa9db7b37770dd95702807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Test related methods.</div></td></tr>
<tr class="memitem:ad684d25913e8aaf0139fa3dc47ce9e40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#ad684d25913e8aaf0139fa3dc47ce9e40">do_pseudo_bdos</a> (bool should)</td></tr>
<tr class="memdesc:ad684d25913e8aaf0139fa3dc47ce9e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CPU to resolve calls to BDOS internally.  <a href="classcpu.html#ad684d25913e8aaf0139fa3dc47ce9e40">More...</a><br /></td></tr>
<tr class="separator:ad684d25913e8aaf0139fa3dc47ce9e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf017b99cf39776da5a4bf517fb9226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#abbf017b99cf39776da5a4bf517fb9226">set_pseudo_bdos_redirect</a> (const char *filename)</td></tr>
<tr class="memdesc:abbf017b99cf39776da5a4bf517fb9226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect pseudo BDOS print routines to a file.  <a href="classcpu.html#abbf017b99cf39776da5a4bf517fb9226">More...</a><br /></td></tr>
<tr class="separator:abbf017b99cf39776da5a4bf517fb9226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850125d4d67383c10cbb1ba594d1db18"><td class="memItemLeft" align="right" valign="top"><a id="a850125d4d67383c10cbb1ba594d1db18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpu.html#a850125d4d67383c10cbb1ba594d1db18">reset_pseudo_bdos_redirect</a> ()</td></tr>
<tr class="memdesc:a850125d4d67383c10cbb1ba594d1db18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect pseudo BDOS print routines back to stdout. <br /></td></tr>
<tr class="separator:a850125d4d67383c10cbb1ba594d1db18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class bus_iface = bus&amp;&gt;<br />
class cpu&lt; bus_iface &gt;</h3>

<p>Represents the CPU of the emulator. </p>
<p>This is the 8080 CPU emulator and interpreter. It abstracts the CPU functionality into straightforward methods and presents a way to step and interact with state. Being an interpreter, each opcode starting from the program counter address in cardbus is fetched and executed according to what it represents and including further fetches to opcode operands. The API also provides public access to <a class="el" href="classcpu.html#a9d70c847732b6891a759352d27e896ee" title="Executes a single opcode.">execute()</a>, should the user want to manually ask for instructions.</p>
<dl class="section note"><dt>Note</dt><dd>The class is completely defined in this header to allow templating the class to determine what bus interface <code>bus_iface</code> to use. For example, you can:<ul>
<li><code>cpu&lt;bus&amp;&gt; <a class="el" href="classcpu.html" title="Represents the CPU of the emulator.">cpu(cardbus)</a>;</code> or <code>cpu&lt;&gt; <a class="el" href="classcpu.html" title="Represents the CPU of the emulator.">cpu(cardbus)</a>;</code> to create a standard CPU that interacts with a bus, or</li>
<li><code>cpu&lt;std::array&lt;u8, 65536&gt;&gt; cpu({ 0 });</code> to instead have an empty array as a bus, for max performance! </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad684d25913e8aaf0139fa3dc47ce9e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad684d25913e8aaf0139fa3dc47ce9e40">&#9670;&nbsp;</a></span>do_pseudo_bdos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::do_pseudo_bdos </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CPU to resolve calls to BDOS internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">should</td><td>Whether the CPU should handle BDOS calls.</td></tr>
  </table>
  </dd>
</dl>
<p>This method enables pseudo BDOS functionality by the CPU itself. This can be essential for testing the CPU, as most diagnostic programs expect the system to be able to print messages. </p>

</div>
</div>
<a id="a9d70c847732b6891a759352d27e896ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d70c847732b6891a759352d27e896ee">&#9670;&nbsp;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::execute </td>
          <td>(</td>
          <td class="paramtype">u8&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a single opcode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>The opcode to execute.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is a comprehensive jump table for all the opcodes the 8080 CPU can execute. It effectively groups the decode and execute phases of the CPU into a single method, and is used by the step method to execute instructions.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Currently, this method is useless for instructions with operands, since their implementation always fetches from the address bus the CPU is aware of. </dd></dl>

</div>
</div>
<a id="a010e335fc9f1797e72bfc5585e9238f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010e335fc9f1797e72bfc5585e9238f6">&#9670;&nbsp;</a></span>is_halted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::is_halted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the CPU is halted. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the CPU is halted, false otherwise. </dd></dl>

</div>
</div>
<a id="a0d839c16cc808245a4f0c38a430a342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d839c16cc808245a4f0c38a430a342a">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<div class="memtemplate">
template&lt;typename T , T_ITERATOR_SFINAE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::load </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_reset_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads data into cardbus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the beginning of data. </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to the end of data. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset to try to start loading at. </td></tr>
    <tr><td class="paramname">auto_reset_vector</td><td>Whether the zero page should point to the start of loaded data automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;tt&gt;std::out_of_range&lt;/tt&gt;</td><td>if data won't fit in cardbus. </td></tr>
    <tr><td class="paramname">&lt;tt&gt;std::out_of_range&lt;/tt&gt;</td><td>if enabled auto reset vector will overwrite the first few bytes loaded.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be useful to load programs, libraries, or data into the emulator's cardbus. It will copy the data at the specified offset, check if it will fit, and if auto_reset_vector is true, it will set the zero page (the first 3 bytes of cardbus, specifically a jump instruction and a 2 byte argument) to point to the start of the loaded data. </p>

</div>
</div>
<a id="a6c72852ac69a7814d8e0faa836d3abf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c72852ac69a7814d8e0faa836d3abf3">&#9670;&nbsp;</a></span>load_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::load_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcpu__state.html">cpu_state</a> &amp;&#160;</td>
          <td class="paramname"><em>new_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load CPU state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_state</td><td>The state to load.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can set a new state to the CPU, including all registers and flags of it. </p>

</div>
</div>
<a id="ae6100df727ce03c23512fee8d2698fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6100df727ce03c23512fee8d2698fc5">&#9670;&nbsp;</a></span>save_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcpu__state.html">cpu_state</a> <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::save_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save CPU state. </p>
<dl class="section return"><dt>Returns</dt><dd>The current state of the CPU.</dd></dl>
<p>This method will return the current state of the CPU, including all registers and flags of it. </p>

</div>
</div>
<a id="abbf017b99cf39776da5a4bf517fb9226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf017b99cf39776da5a4bf517fb9226">&#9670;&nbsp;</a></span>set_pseudo_bdos_redirect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::set_pseudo_bdos_redirect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Redirect pseudo BDOS print routines to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to print to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd0b563c6831d88a883f3bcd7d2257b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0b563c6831d88a883f3bcd7d2257b4">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class bus_iface  = bus&amp;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpu.html">cpu</a>&lt; bus_iface &gt;::step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steps the CPU by one instruction (and its operands). </p>
<p>Calling the step method will fetch the next instruction opcode from cardbus and execute it. Internally, on every fetch the PC is incremented, and each instruction is also responsible for fetching its operands, so a step is effectively a full instruction step.</p>
<p>If the CPU is set to handle BDOS calls, it will provide some pseudo BDOS functionality, currently only for printing characters and strings to wherever the printer is set to, stdout by default.</p>
<dl class="section note"><dt>Note</dt><dd>If the CPU is halted, this method will return immediately. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally, this method is calling <code>execute(fetch())</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/core/cpu/<a class="el" href="cpu_8hpp_source.html">cpu.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classcpu.html">cpu</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
